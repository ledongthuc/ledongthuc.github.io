<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>OS Kernel Assembly</title><meta name=description content="A space where I put my notes, researches and stuffs."><link href="https://fonts.googleapis.com/css?family=Fira+Sans|Roboto|Zilla+Slab&display=swap" rel=stylesheet><link rel=stylesheet href=/css/style.css?1657051200><meta property="og:title" content="Thuc notes - OS Kernel Assembly"><meta property="og:description" content="First part of the kernel that will be called by bootloader. It&rsquo;s gate of kernel before accessing higher level code"><meta property="og:image" content="https://thuc.space/images/os_kernel_assembly/os_kernel_assembly.png"><meta property="og:image:type" content="image/png"><meta property="og:type" content="website"></head><body><div class=header>Thuc notes &copy; 2022<div class=menu>| <a href=/>home</a>
| <a href=/series/>series</a>
| <a href=/tags/>tags</a>
| <a href=/about-me/>about me</a></div></div><h1>OS Kernel Assembly</h1><div class=main><div class=article>Part of series <a class=series href=/series/osdev>osdev</a> |
<time>2021-08-29</time><div class=content><ul><li>First part of the kernel. Will be called by the bootloader.</li><li>Define a mechanism that the bootloader can recognize and load the system kernel.</li><li>It implements the logic that can&rsquo;t handle from a high-level kernel.</li><li>Basic functions:<ul><li>Define a function <code>_start</code> that will be jumped to from bootloader as an entry-point.</li><li>Responsible to allocate stack to use.</li><li>Transfer to the high-level kernel by calling to function written by C, C++, Go, Rust etc.</li><li>Keep the computer in an infinite loop.</li></ul></li></ul><h1 id=1-multiboot-standard-layout>1. Multiboot standard layout</h1><ul><li>An interface standard that&rsquo;s used by the bootloader to recognize and load the system kernel.</li><li>Bootloader will search multiboot headers (magic numbers) to recognize the kernel as multiboot compatible.</li></ul><h2 id=11-header-layout>1.1. Header layout</h2><p><img src=/images/os_kernel_assembly/os_kernel_assembly.png alt="multiboot header"></p><table><thead><tr><th>Offset</th><th>Type</th><th>Field</th></tr></thead><tbody><tr><td>0</td><td>unsigned 32-bit</td><td>magic number</td></tr><tr><td>4</td><td>unsigned 32-bit</td><td>flags</td></tr><tr><td>8</td><td>unsigned 32-bit</td><td>checksum</td></tr><tr><td>12</td><td>unsigned 32-bit</td><td>header_addr</td></tr><tr><td>16</td><td>unsigned 32-bit</td><td>load_addr</td></tr><tr><td>20</td><td>unsigned 32-bit</td><td>load_end_addr</td></tr><tr><td>24</td><td>unsigned 32-bit</td><td>bss_end_addr</td></tr><tr><td>28</td><td>unsigned 32-bit</td><td>entry_addr</td></tr><tr><td>32</td><td>unsigned 32-bit</td><td>mode_type</td></tr><tr><td>36</td><td>unsigned 32-bit</td><td>width</td></tr><tr><td>40</td><td>unsigned 32-bit</td><td>height</td></tr><tr><td>44</td><td>unsigned 32-bit</td><td>depth</td></tr></tbody></table><h3 id=111-header-magic-fields>1.1.1. Header magic fields</h3><ul><li>Include: magic number, flags and checksum</li></ul><p><strong>Magic number</strong></p><ul><li>The hexadecimal value always is 0x1BADB002</li></ul><p><strong>Flags:</strong></p><ul><li>Control address fields and graphics fields.</li><li>Bits 0-15 is a required feature. If the boot loader can&rsquo;t understand the flag or fulfil them, it fails to load the OS image.</li><li>Bits 16-31 is optional features. If the boot loader can&rsquo;t understand the flag or can&rsquo;t fulfil them, it&rsquo;s ignored.</li></ul><table><thead><tr><th>Bit</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>If it&rsquo;s set, all boot modules loaded with must be aligned on 4KB page boundaries</td></tr><tr><td>1</td><td>If it&rsquo;s set, mem_lower and mem_upper in multiboot information structure, that&rsquo;s passed by the boot loader to OS, must be included. mmap_length and mmap_addr are had in case the boot loader can pass it to.</td></tr><tr><td>2</td><td>If it&rsquo;s set, information about video mode table must be available in multiboot information structure, the boot loader passes that to OS, must be included</td></tr><tr><td>16</td><td>If it&rsquo;s set, header address fields are used by boot loader instead of the fields in the actual executable header. Don&rsquo;t need to provide if the kernel image is in ELF format, required if it&rsquo;s a.out format or in some other format</td></tr></tbody></table><p><strong>checksum:</strong></p><ul><li>Value&rsquo;s always <code>-(magic number + flags)</code></li></ul><h3 id=112-header-address-fields>1.1.2. Header address fields</h3><ul><li>All of the address fields enabled by flag bit 16 are physical addresses.</li><li>Include: header_addr, load_addr, load_end_addr, bss_end_addr and entry_addr</li><li>header_addr: the physical address of the beginning of the multiboot header.</li><li>load_addr: the physical address of the beginning of text segment.</li><li>load_end_addr: the physical address of the end of the data segment. So the text and data segment are consecutive in the OS image.</li><li>bss_end_addr: the physical address of the end of the BSS segment.</li><li>entry_addr: the physical address to jump to start OS from the boot loader.</li></ul><h3 id=113-header-graphics-fields>1.1.3. Header graphics fields</h3><ul><li>All of the graphics fields are enabled by flag bit 2.</li><li>Include: mode_type, width, height and depth</li><li>Specify the preferred graphics mode</li><li>Recommended mode by OS image, the boot loader may choose a different mode if it sees fit.</li><li>mode_type: 0 = linear graphics mode, 1 = EGA-standard text mode</li><li>width: The number of columns</li><li>height: The number of the lines</li><li>depth: The number of bits per pixel in a graphics mode, zero in a text mode.</li></ul><h2 id=12-stack-definition>1.2. Stack definition</h2><ul><li>Create a section; allocate 16 Kb; create a symbol at the top by setting the esp register. The stack grows downwards on x86.</li><li>Aligned 16-byte according to the System V ABI standard and de-facto extensions</li></ul><h2 id=13-infinite-loop>1.3. Infinite loop</h2><ul><li>Disable CLI interrupts</li><li>Use <code>hlt</code> to wait for the next interrupt to archive.</li><li>Jump back to the waiting step for <code>hlt</code> again if the computer wakes up by any interrupting.</li></ul><h2 id=14-multiboot-information-structure>1.4. Multiboot information structure</h2><ul><li>Multiboot information structure is data that the boot loader communicates to the OS.</li><li>The EBX register contains the physical address of the multiboot information structure.</li></ul><table><thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>flags</td><td></td></tr><tr><td>4</td><td>4</td><td>mem_lower</td><td>Memory definition</td></tr><tr><td>8</td><td>4</td><td>mem_upper</td><td>Memory definition</td></tr><tr><td>12</td><td>4</td><td>boot_device</td><td>Boot device information</td></tr><tr><td>16</td><td>4</td><td>cmdline</td><td>Command line information</td></tr><tr><td>20</td><td>4</td><td>mods_count</td><td>Loadded modules</td></tr><tr><td>24</td><td>4</td><td>mods_addr</td><td>Loadded modules</td></tr><tr><td>28-40</td><td>16</td><td>syms</td><td>Detail fields between those addresses are controlled by the flag</td></tr><tr><td>44</td><td>4</td><td>mmap_length</td><td>Memory map</td></tr><tr><td>48</td><td>4</td><td>mmap_length</td><td>Memory map</td></tr><tr><td>52</td><td>4</td><td>drives_length</td><td>Drives</td></tr><tr><td>56</td><td>4</td><td>drives_addr</td><td>Drives</td></tr><tr><td>60</td><td>4</td><td>config_table</td><td>Config table</td></tr><tr><td>64</td><td>4</td><td>boot_loader_name</td><td>Boot loader name</td></tr><tr><td>68</td><td>4</td><td>apm_table</td><td>Advanced Power Management table</td></tr><tr><td>72</td><td>16 (2 for each)</td><td>vbe_*</td><td></td></tr><tr><td>88</td><td>21</td><td>framebuffer_*</td><td>framebuffer</td></tr></tbody></table><p><strong>Flags:</strong></p><ul><li>Indicates features are defined in the following fields will be used.</li></ul><table><thead><tr><th>Bit</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>Enable mem_lower and mem_upper fields to control memory boundary</td></tr><tr><td>1</td><td>Enable to set the boot_device fields</td></tr><tr><td>2</td><td>Enable to set the cmdline fields</td></tr><tr><td>3</td><td>Enable to set the modules fields</td></tr><tr><td>4</td><td>Defile structure offset 28-40. 4 or 5 is set, another is unset.</td></tr><tr><td>6</td><td>Enable to set the memory map fields</td></tr><tr><td>7</td><td>Enable to set the drives fields</td></tr><tr><td>8</td><td>Enable to set the config table field</td></tr><tr><td>9</td><td>Enable to set the boot loader name field</td></tr><tr><td>10</td><td>Enable to set the Advanced Power Management table fields</td></tr><tr><td>11</td><td>Enable to set the VBE fields</td></tr><tr><td>12</td><td>Enable to set the framebuffer fields</td></tr></tbody></table><p><strong>Memory:</strong></p><ul><li><code>mem_lower, mem_upper</code>.</li><li>Define total available memory that can use.</li></ul><p><strong>Boot device:</strong></p><ul><li><code>boot_device</code>.</li><li>Indicate boot device which BIOSK disk device the boot loader loaded the OS image from</li><li>If the OS is not booted by BIOSK disk, it should be clear.</li></ul><p><strong>Command line:</strong></p><ul><li><code>cmdline</code>, byte offset = 16, size = 4.</li><li>Define the physical address of the command line that is passed to the kernel.</li></ul><p><strong>Modules:</strong></p><ul><li><code>mods_count, mods_addr</code>.</li><li>Indicate what boot modules were loaded along with the kernel image.</li><li><code>mods_count</code> = number of modules loaded.</li><li><code>mods_addr</code> = physical address of the first module.</li><li>Each module will have the following structure</li></ul><table><thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>mod_start</td><td>physical starting address of module</td></tr><tr><td>4</td><td>4</td><td>mod_end</td><td>physical ending address of module</td></tr><tr><td>8</td><td>4</td><td>mod_end</td><td>arbitrary string of module. It can be command line, pathname</td></tr><tr><td>12</td><td>4</td><td>reserved</td><td>set 0 by the boot loader and ignored by OS</td></tr></tbody></table><p><strong>Symbol table:</strong></p><ul><li>If bit 4 of the flag are set, the following symbol location info is used</li></ul><table><thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>28</td><td>4</td><td>tabsize</td><td>size parameter</td></tr><tr><td>32</td><td>4</td><td>strsize</td><td>size parameter</td></tr><tr><td>36</td><td>4</td><td>addr</td><td>physical address of and array of a.out format nlist structures</td></tr><tr><td>40</td><td>4</td><td>reserved</td><td>just for reversed</td></tr></tbody></table><ul><li>If bit 5 of the flag are set, the following s section header table from ELF info is used</li></ul><table><thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>28</td><td>4</td><td>num</td><td>number of entries</td></tr><tr><td>32</td><td>4</td><td>size</td><td>size of each entry</td></tr><tr><td>36</td><td>4</td><td>addr</td><td>Physical address fields of the ELF section header</td></tr><tr><td>40</td><td>4</td><td>shndx</td><td></td></tr></tbody></table><p><strong>Memory map:</strong></p><ul><li><code>mmap_length, mmap_addr</code></li><li>Indicate a buffer containing a memory map starting address and its length. BIOS provides the buffer having a memory map. The map provided is guaranteed to list all standard RAM that should be available for usage.</li><li>Each item in the memory map has structure:</li></ul><table><thead><tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>-4</td><td>4</td><td>size</td><td>size of memory map item</td></tr><tr><td>0</td><td>8</td><td>base_addr</td><td>physical address of the memory that the map define to</td></tr><tr><td>8</td><td>8</td><td>length</td><td>the size of the memory region</td></tr><tr><td>16</td><td>8</td><td>type</td><td>the variety of address range represented. 1 = available RAM, 3 = usable memory holding ACPI information, 4 = reserved memory which needs to be preserved on hibernation, 5 = occupied by defective RAM modules and all other values currently indicated a reserved area</td></tr></tbody></table><p><strong>Drives:</strong></p><ul><li><code>drives_length, drives_addr</code></li><li>Indicate the address of the physical address of the first drive structure and the size of drive structures.</li></ul><p><strong>Config table:</strong></p><ul><li><code>config_table</code></li><li>Indicates the address of the ROM configuration table returned by the <code>GET CONFIGURATION BIOS</code> call</li></ul><p><strong>Boot loader name:</strong></p><ul><li><code>boot_loader_name</code></li><li>Contains the physical address of the name of a boot loader booting the kernel</li></ul><p><strong>Advanced Power Management table:</strong></p><ul><li><code>apm_table</code></li><li>Contains the physical address of an <a href=https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface>Advanced Power Management table</a>.</li></ul><p><strong>VBE</strong></p><ul><li>All fields starts with <code>vbe_</code></li><li>Indicate fields of <a href=https://en.wikipedia.org/wiki/VESA_BIOS_Extensions>VESA BIOS extensions</a>.</li></ul><p><strong>Graphics</strong></p><ul><li>All fields starts with <code>framebuffer_</code></li><li>Indicate fields of <a href=https://en.wikipedia.org/wiki/Framebuffer>framebuffer table</a>.</li></ul><h1 id=2-multiboot2-standard-layout>2. Multiboot2 standard layout</h1><ul><li>TBD.</li></ul><h2 id=21-header>2.1. Header</h2><ul><li>Magic number: 0xE85250D6</li></ul><h1 id=3-references>3. References</h1><ul><li><a href=https://wiki.osdev.org/Bare_Bones>https://wiki.osdev.org/Bare_Bones</a></li><li><a href=https://wiki.osdev.org/Multiboot>https://wiki.osdev.org/Multiboot</a></li><li><a href=https://www.gnu.org/software/grub/manual/multiboot/multiboot.html>https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></li></ul></div><div class=tags>Tags: <a class=tag href=/tags/x86>x86</a> | <a class=tag href=/tags/mbr>mbr</a> | <a class=tag href=/tags/boot>boot</a> | <a class=tag href=/tags/kernel>kernel</a> |</div></div></div></body></html>